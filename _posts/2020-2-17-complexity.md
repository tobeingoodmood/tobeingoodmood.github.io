---
layout: post
title: "算法复杂度分析"
date:   2020-06-09
tags: [Kent.D]
comments: true
author: Kent.D
toc: true
---



在分析算法时，我们需要考虑时间复杂度和空间复杂度。 算法的时间复杂度根据输入长度来量化算法运行所需的时间。 类似地，算法的空间复杂度将算法占用的空间或内存量量化为输入长度的函数。时间和空间的复杂性取决于许多因素，例如硬件，操作系统，处理器等。但是，在分析算法时，一般不考虑这些因素，而只考虑算法的执行时间。


时间复杂度/计算复杂度描述了运行算法所需花费的时间。通常，假定每个基本运算都需要固定的时间来执行，则可以通过计数算法中包含的基本运算的数量来估算复杂度。由于算法的运行时间在相同大小的不同输入之间可能会有所不同，因此通常会考虑最坏情况下的时间复杂度，即给定输入所需的最大时间量。


使用阶数表示可以更方便的表示复杂度，低阶项相对来说是可以忽略的，因此通常被省略。O-natation表示法表示渐近上限,这也是我们最常考虑的。即，O（g(n)）表示存在常数c和$n_0$, 使得对于所有的$n \ge n_0, 有0 \le f(n) \le cg(n)$，其中$f(n)$是运行时间。比如: 
$f(N)=2*N^3+4*N^2+5*N+9$,则$O(f(N))=O(N^3)$。


例1：假设给定一个数组和一个整数，现在需要查找数组中是否存在该整数：

```
for i : 1 to length of A
    if A[i] is equal to x
        return TRUE
return FALSE
```

假定计算机中的每个操作需要固定的时间为c。 执行的代码行数实际上取决于x的值。 在算法分析期间，大多数情况下我们会考虑最坏情况，即数组中不存在x的情况。 在最坏的情况下，if条件需要运行N次（N是数组的长度）。 因此，在最坏的情况下，总执行时间为$(Nc+c)$。$Nc$为$if$条件执行时间，$c$是return执行时间（忽略i的赋值操作）。可以看出，总时间取决于数组的长度。如果数组的长度增加，执行时间也会增加。可以看到执行时间线性依赖于数组的长度，即复杂度为$O(N)$.


例2：
```
int count = 0;
for (int i = 0; i < N; i++) 
    for (int j = 0; j < i; j++) 
        count++;
```
当i=0，执行0次；

当i=1，执行1次；

当i=2，执行2次；……

因此最终count++执行了0+1+2+……=N(N-1)/2,则复杂性是$O（N^2）$，
这里等价于计算 
$\sum\limits_{i = 0:N-1}{\sum\limits_{j = i}x}$.

例3：
```
int count = 0;
for (int i = N; i > 0; i /= 2) 
    for (int j = 0; j < i; j++) 
        count++;
```
当i=N，执行N次；

当i=N/2，执行N/2次；

当i=N/4，执行N/4次；

因此最终count++执行了N+ N/2+ N/4+……=2N,则复杂性是$O（N）.$

